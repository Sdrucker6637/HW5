# HW5

Spencer Drucker

I pledge my honor that I have abided by the Stevens Honor System.- SD

**Design**

1. When thinking about the design cases for this project, thinking in terms of use cases was very helpful. Considering use cases are very basic instances of the code being used, it helped in thinking what the user would want to do and how they would do it. In turn, knowing what they would want to do and how would they do helped to streamline the implementation process since we had a basic design of how the system would behave.


2. The most difficult part of the design process for me was the UMLet design features. For ours, the sequence diagram was quite difficult. Knowing the sequences themselves was not too tough (it was just the different parts of the project). The difficulty was in knowing the processes that connected each step. If I were to do it differently, I would likely not do this step at all because it was essentially useless in the grand scheme of things. However, if I did need something similar, I think a use case diagram would be slightly more useful with each use case connecting to the user.


3. One design method I would take would be the storyboard. Having a storyboard is equivalent to an artist having a vision for their work. It gives a sense of purpose and steers you on the correct path of how your design should work. The other design method I would use in the future would be the use cases. Use cases help think in terms of the basics of the functionality using a relatively simple design. 

**Implementation**

1. The most helpful part in the implementation, testing, and integration of the bot was the simplicity of the Discord API. The way Discord is integrated into Python is fairly simple. There are no complex codes needed and nearly everything that I coded was fairly simplistic. The Reddit API was also quite helpful in its ease of use, as well. Both of the APIs we used were very simplistic and self-explanatory.


2. I would say the two most difficult aspects of the implementation were initially setting up the Reddit server and using embed in Discord/Python. In terms of the setting up, this was not as difficult as it was confusing. It was a bit hard to understand the aspects of what goes into the Reddit credentials and why. However, once that was figured out, it was not too difficult. The other issue was the embed. This was tough to get the hang of at first, with it not being very straightforward in its implementation. However, once we were able to get it working for one instance, we were able to copy it for the rest.


3. If working on another project with a group, I think that one testing method I would use is having other people attempt to break your code. We did this with the functions we each programed and it was a great practice. Similar to when somebody writes something, they are less likely to see the errors, the same thing occurs when coding. Having someone unfamiliar with what you coded attempt to push the code to its limits helps prepare for when the project is live and fully implemented and anyone can do as they please with the code.

**Process**

1. As previously mentioned in the Design section, I believe that the Kanban/Project Board is a fantastic tool to have. It helped with micromanaging not just the whole project, but individual functions and tasks, as well. Having a tool that displayed what tasks needed to be done, who was working on each task, and their level of importance helped me prioritize my tasks and break them down to help the process. It made the whole project in general seem very manageable and comprehensible. The code review was also a nice implementation as well since we could each write code and then later someone can review it and suggest changes without a single meeting needed.


2. The most difficult part of the process was using the pull requests and merges with the code review. To me, this process is a bit difficult to understand and get a firm grasp of how it works. Creating a new branch is not difficult, nor is understanding how the branches work. I just found the act of making pull requests and merging branches to not only be quite confusing but also overwhelming since there is a likelihood you can incorrectly merge or pull and cause an issue.


3. One process I would use on another project would be the Project Board because of its simplicity and the above-mentioned reasons. Having the project board for me helped solve one of my major issues when coding, that being knowing how and where to start. The microtasks helped to eliminate this issue for me. I definitely would like to further my understanding of merging and pulling because I definitely see the use of the feature, now it is just knowing how it is done.






**Overall**

	Overall this project really felt like my beginning to real-world coding experiences. This project felt like one of the first times where everyone was not only contributing code to the project, but we were also seeing the impact of our code and our progress on our group membersâ€™ work. I think there are some very valuable lessons I will take away from this project. Some takeaways for me include having use cases to help me think like a user. It is also important to have a storyboard so that you can have a vision of what the future of your project will look like. While these two design methods were useful, the UMLet aspect to me did not seem very useful and it did not have a tremendous impact on our project. So I would definitely take the other two design methods and incorporate them with the other developer testing of code for the implementation. Having everyone know how it should behave and what it should look like and then testing that against your code and seeing if it holds up helps to create solid code. Lastly, having the storyboard, the use cases, the other developers testing helps with the kanban and code review in the process implementation. The use cases help develop the tasks within the kanban, and the storyboard helps implement microtasks and features within those tasks. Having the pull requests and merging helps make the process of reviewing code that much easier. The three cornerstones of creating a good code project: design, process, and implementation all need each other, and all need to be executed well to create a successful project.
